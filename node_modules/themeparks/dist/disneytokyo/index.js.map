{"version":3,"sources":["../../lib/disneytokyo/index.js"],"names":["cheerio","require","cookie","Moment","Park","GeoLocation","s_parkID","Symbol","s_parkKind","s_parkLocationMin","s_parkLocationMax","DisneyTokyoPark","options","name","park_id","Error","park_kind","location_min","location_max","Promise","resolve","GetRideNames","then","rideData","FetchWaitTimesURL","HTML","ParseWaitTimesHTML","rideTimes","rideID","rideObject","GetRideObject","id","WaitTime","FastPass","GetAcccessToken","access_token","HTTP","url","headers","encodeURIComponent","connection","$","load","results","rides","i","ride","el","ride_data","ride_url","find","attr","ride_id_match","exec","text","indexOf","waitTime","length","parseInt","remove","isNaN","reject","today","tz","Timezone","FetchOpeningTimesForMonth","format","add","bind","month","forceJSON","body","entry","date","scheduleDate","Schedule","SetDate","openingTime","open_time_1","closingTime","close_time_1","cookieExpire","Cache","Wrap","randomGeoLocation","RandomBetween","data","nextUrl","lat","LatitudeRaw","lng","LongitudeRaw","follow_max","returnFullResponse","resp","GPSCookie","GPSExpiresIn","cookie_string","cookie_data","parse","tdrloc","diff","expires","Log","entries","str_id","name_yomi","module","exports","parent","S","latitude","longitude","readFileSync","__dirname","JSON","stringify"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\r\n\r\n// cherrio, our web scraping library\r\nvar cheerio = require(\"cheerio\");\r\n// cookie library for reading geocookie for wait times\r\nvar cookie = require(\"cookie\");\r\n\r\nvar Moment = require(\"moment-timezone\");\r\n\r\nvar Park = require(\"../park\");\r\nvar GeoLocation = require(\"../geoLocation\");\r\n\r\nvar s_parkID = Symbol();\r\nvar s_parkKind = Symbol();\r\nvar s_parkLocationMin = Symbol();\r\nvar s_parkLocationMax = Symbol();\r\n\r\n// token history (maybe we can just calculate it instead of fetching it??)\r\n// 25th 17:30: 2Gz2/J+AAhLVQsYnVWXzmFRR\r\n// 25th 18:00: 2Gz2/J+AAhLVQsYnVWXzmFRR\r\n// September 25th: 2Gz24oWAAhLVQsYnVWXzmFRS\r\n// September 5th:  2GH25YWLFRfNG9QlVGL1kV9XCg==\r\n// August 29th:    2GD2/J+AAhLVQsYnVWXzmVRe\r\n// August 28th:    2GD2/J+AAhLVQsYnVWXzmVRe\r\n// July 31st:      2GT24oWAAhLVQsYnVWXzllVW\r\n// July 13th:      2WP25ZibFADIA403VmPyl1ZQDbc=\r\n// May 31st:       2WX25YWLFRfNG9QlVGL1kVNUDQ==\r\n// May 30th:       2WX2/J+AAhLVQsYnVWXzlFVX\r\n// April 17th:     2mH24oWAAhLVQsYnVWXzlVdQ\r\n// April 16th:     2mH24pGaEwHIA403VmPyl1ZTDbU=\r\n\r\n/**\r\n * Implements the Tokyo Disneyland API framework.\r\n * @class\r\n * @extends Park\r\n */\r\nclass DisneyTokyoPark extends Park {\r\n    /**\r\n     * Create new DisneyTokyoPark Object.\r\n     * This object should not be called directly, but rather extended for each of the individual Tokyo Disneyland parks\r\n     * @param {Object} options\r\n     * @param {String} options.park_id Tokyo Disneyland API park ID\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Tokyo Disneyland Park\";\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // assign park configurations\r\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\r\n        this[s_parkID] = options.park_id;\r\n        if (!options.park_kind) throw new Error(\"Missing park's kind ID\");\r\n        this[s_parkKind] = options.park_kind;\r\n        // geoip range for generating valid cookie\r\n        //  specify as two Location points\r\n        if (!options.location_min || !(options.location_min instanceof GeoLocation)) throw new Error(\"Missing park's min location\");\r\n        if (!options.location_max || !(options.location_max instanceof GeoLocation)) throw new Error(\"Missing park's max location\");\r\n        this[s_parkLocationMin] = options.location_min;\r\n        this[s_parkLocationMax] = options.location_max;\r\n    }\r\n\r\n    // override Fastpass Getter to declare support for Fastpass\r\n    get FastPass() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Refresh/Fetch new Wait Times for this Tokyo Disney Resort park\r\n     * @returns {Promise}\r\n     */\r\n    FetchWaitTimes() {\r\n        return new Promise((resolve) => {\r\n            // get ride names\r\n            this.GetRideNames().then((rideData) => {\r\n                // fetch wait times HTML page\r\n                this.FetchWaitTimesURL().then((HTML) => {\r\n                    // parse HTML data\r\n                    this.ParseWaitTimesHTML(HTML).then((rideTimes) => {\r\n                        for (var rideID in rideData) {\r\n                            // find ride object (using ride names, not actual wait time data)\r\n                            //  why? because when the park closes, the HTML page is empty\r\n                            //  so, we want to check each ride for data, if it's missing data, the park/ride is assumed closed\r\n                            var rideObject = this.GetRideObject({\r\n                                id: rideID,\r\n                                name: rideData[rideID]\r\n                            });\r\n\r\n                            if (rideObject) {\r\n                                if (rideTimes[rideID]) {\r\n                                    // update ride with new waittime data\r\n                                    rideObject.WaitTime = rideTimes[rideID].WaitTime;\r\n                                    rideObject.FastPass = rideTimes[rideID].FastPass;\r\n                                } else {\r\n                                    // ride isn't on the website. Most like park is closed, so set wait time to -1 to mark as inactive\r\n                                    rideObject.WaitTime = -1;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    FetchWaitTimesURL() {\r\n        return this.GetAcccessToken().then((access_token) => {\r\n            return this.HTTP({\r\n                url: `http://info.tokyodisneyresort.jp/rt/s/realtime/${this[s_parkID]}_attraction.html`,\r\n                headers: {\r\n                    \"Cookie\": `tdrloc=${encodeURIComponent(access_token)}`,\r\n                    connection: \"keep-alive\",\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    ParseWaitTimesHTML(HTML) {\r\n        // load HTML using cheerio\r\n        var $ = cheerio.load(HTML);\r\n\r\n        var results = {};\r\n\r\n        var rides = $(\".schedule .midArw\");\r\n        for (var i = 0, ride; ride = rides[i++];) {\r\n            var el = $(ride);\r\n            var ride_data = {};\r\n\r\n            // extract URL (finding ride name/id)\r\n            var ride_url = el.find(\"a\").attr(\"href\");\r\n            var ride_id_match = /attraction\\/detail\\/str_id:([a-z0-9_]+)/gi.exec(ride_url);\r\n\r\n            // if we can't get a ride ID, just continue\r\n            if (!ride_id_match) {\r\n                continue;\r\n            }\r\n\r\n            // got the ride ID!\r\n            ride_data.id = ride_id_match[1];\r\n\r\n            // get waiting time!\r\n            // first, check for rides under maintenance\r\n            if (\r\n                // ride down for refurb/off-season (closed all day)\r\n                el.text().indexOf(\"運営・公演中止\") >= 0\r\n                // ride unexpectedly closed\r\n                ||\r\n                el.text().indexOf(\"一時運営中止\") >= 0\r\n                // \"special type\" closed, for non-standard attractions such as walking experiences or transport\r\n                ||\r\n                el.text().indexOf(\"案内終了\") >= 0) {\r\n                // found the maintenance text, mark ride as inactive\r\n                ride_data.WaitTime = -1;\r\n            } else {\r\n                var waitTime = el.find(\".waitTime\");\r\n                if (!waitTime || !waitTime.length) {\r\n                    ride_data.WaitTime = 0;\r\n                } else {\r\n                    // extract number\r\n                    ride_data.WaitTime = parseInt(waitTime.remove(\"span\").text(), 10);\r\n                    // if we didn't get a number, time is unavailable! (but ride is still open)\r\n                    //  this usually means you have to go to the ride to get wait times, and they're not on the app\r\n                    if (isNaN(ride_data.WaitTime)) ride_data.WaitTime = -1;\r\n                }\r\n            }\r\n\r\n            // fast pass status\r\n            if (el.find(\".fp\").length) {\r\n                // does this ride have FastPass?\r\n                ride_data.FastPass = true;\r\n            } else if (el.find(\".fp-no\")\r\n                .length) {\r\n                // ride supports fastpass! but they've ran out\r\n                ride_data.FastPass = true;\r\n            } else {\r\n                // otherwise, assume no fastpasses for this ride\r\n                ride_data.FastPass = false;\r\n            }\r\n\r\n            results[ride_data.id] = ride_data;\r\n        }\r\n\r\n        return Promise.resolve(results);\r\n    }\r\n\r\n    FetchOpeningTimes() {\r\n        return new Promise(function(resolve, reject) {\r\n            // fetch 3 months of schedule data\r\n            var today = Moment().tz(this.Timezone);\r\n            this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                today.add(1, \"month\");\r\n                this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                    today.add(1, \"month\");\r\n                    this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                        resolve();\r\n                    }.bind(this), reject);\r\n                }.bind(this), reject);\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    FetchOpeningTimesForMonth(month) {\r\n        return new Promise(function(resolve, reject) {\r\n            this.HTTP({\r\n                url: `http://www.tokyodisneyresort.jp/api/v1/wapi_monthlycalendars/detail/ym:${month}/`,\r\n                headers: {\r\n                    \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    connection: \"keep-alive\",\r\n                },\r\n                forceJSON: true\r\n            }).then(function(body) {\r\n                if (!body || !body.entry) return reject(\"Failed to find data from TDR calendar\");\r\n\r\n                for (var date in body.entry) {\r\n                    if (body.entry[date][this[s_parkID]]) {\r\n                        var scheduleDate = Moment(date, \"YYYY/MM/DD\");\r\n                        this.Schedule.SetDate({\r\n                            date: scheduleDate,\r\n                            openingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].open_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\r\n                            closingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].close_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\r\n                        });\r\n                    }\r\n                }\r\n\r\n                resolve();\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get the Geo-Locked access token for accessing Tokyo Disneyland wait times\r\n     * @returns {Promise<String>} tdrloc cookie needed for accessing wait time pages\r\n     */\r\n    GetAcccessToken() {\r\n        var cookieExpire;\r\n        return this.Cache.Wrap(\"geocookie\", function() {\r\n            return new Promise(function(resolve, reject) {\r\n                // generate a new geo cookie for accessing Tokyo ride data\r\n                var randomGeoLocation = GeoLocation.RandomBetween(this[s_parkLocationMin], this[s_parkLocationMax]);\r\n\r\n                // request cookie for accessing wait times using a random location in the park\r\n                this.HTTP({\r\n                    url: `https://info.tokyodisneyresort.jp/rt/s/gps/${this[s_parkID]}_index.html`,\r\n                    data: {\r\n                        nextUrl: `http://info.tokyodisneyresort.jp/rt/s/realtime/${this[s_parkID]}_attraction.html`,\r\n                        lat: randomGeoLocation.LatitudeRaw,\r\n                        lng: randomGeoLocation.LongitudeRaw\r\n                    },\r\n                    headers: {\r\n                        connection: \"keep-alive\",\r\n                        \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\r\n                    },\r\n                    // don't actually follow the redirect, we just want the cookie\r\n                    follow_max: 0,\r\n                    // we are actually only interested in the headers, so get the full response, not the body\r\n                    returnFullResponse: true\r\n                }).then(function(resp) {\r\n                    if (resp && resp.headers && resp.headers[\"set-cookie\"] && resp.headers[\"set-cookie\"].length) {\r\n                        // hunt for the tdrloc cookie\r\n                        var GPSCookie, GPSExpiresIn = 60 * 30;\r\n                        for (var i = 0, cookie_string; cookie_string = resp.headers[\"set-cookie\"][i++];) {\r\n                            var cookie_data = cookie.parse(cookie_string);\r\n\r\n                            // search for any tdrloc cookie\r\n                            //  keep searching and keep the last set one\r\n                            //  their server usually sets it twice, first deleting it, then setting the correct one\r\n                            if (cookie_data && cookie_data.tdrloc) {\r\n                                GPSCookie = cookie_data.tdrloc;\r\n                                // parse cookie date to calculate expirey time in seconds\r\n                                GPSExpiresIn = Moment().diff(Moment(cookie_data.expires, \"ddd, DD-MMM-YYYY HH:mm:ss z\"), \"seconds\");\r\n\r\n                                // the cookie can actually be negative if the park is closed (weird, but OK)\r\n                                //  if this is so, keep the current one for 5 minutes and try again\r\n                                if (GPSExpiresIn < 0) {\r\n                                    GPSExpiresIn = 60 * 5;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // did we find the cookie?\r\n                        if (GPSCookie) {\r\n                            // set out-of-scope cookieExpire so we can tell the cache how long to keep this token\r\n                            //  take a little off to be safe (a minute)\r\n                            cookieExpire = GPSExpiresIn - 60;\r\n\r\n                            this.Log(`Fetched new TDR geo-cookie: ${GPSCookie}`);\r\n\r\n                            // return the new cookie\r\n                            resolve(GPSCookie);\r\n                        } else {\r\n                            return reject(\"Failed to find GPS Cookie from TDR website\");\r\n                        }\r\n                    } else {\r\n                        return reject(\"Missing GeoCookie from TDR response\");\r\n                    }\r\n                }.bind(this), reject);\r\n            }.bind(this));\r\n        }.bind(this), function() {\r\n            return cookieExpire;\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Fetch English ride names from the API\r\n     * @returns {Promise<Object>} `rideID` to English names\r\n     */\r\n    GetRideNames() {\r\n        return this.Cache.Wrap(\"ridenames\", function() {\r\n            return new Promise(function(resolve, reject) {\r\n                // fetch ride names\r\n                this.HTTP({\r\n                    url: `http://www.tokyodisneyresort.jp/api/v1/wapi_attractions/lists/sort_type:1/locale:1/park_kind:${this[s_parkKind]}/`,\r\n                    forceJSON: true,\r\n                    headers: {\r\n                        \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\r\n                        connection: \"keep-alive\",\r\n                    },\r\n                }).then(function(body) {\r\n                    if (!body || !body.entries || !body.entries.length) {\r\n                        return reject(\"Failed to find entries in ride data response\");\r\n                    }\r\n\r\n                    // populate data\r\n                    var rideData = {};\r\n                    for (var i = 0, ride; ride = body.entries[i++];) {\r\n                        // use English if we can, fallback to yomi if we're missing an English name\r\n                        rideData[ride.str_id] = ride.name || ride.name_yomi;\r\n                    }\r\n\r\n                    return resolve(rideData);\r\n                }.bind(this), reject);\r\n            }.bind(this));\r\n        }.bind(this), 86400);\r\n    }\r\n}\r\n\r\nmodule.exports = DisneyTokyoPark;\r\n\r\nif (!module.parent) {\r\n    // test example wait times HTML page\r\n    var S = new DisneyTokyoPark({\r\n        latitude: 35.6277563214705,\r\n        longitude: 139.8811161518097,\r\n        park_id: \"tds\",\r\n        park_kind: 2,\r\n        location_min: new GeoLocation({\r\n            latitude: 35.6277563214705,\r\n            longitude: 139.8811161518097\r\n        }),\r\n        location_max: new GeoLocation({\r\n            latitude: 35.62465172824325,\r\n            longitude: 139.88948464393616\r\n        })\r\n    });\r\n\r\n    // fetch new test HTML file\r\n    /*S.FetchWaitTimesURL().then((HTML) => {\r\n        require(\"fs\").writeFileSync(__dirname + \"/test.html\", HTML);\r\n    });*/\r\n\r\n    // test parsing stored HTML file\r\n    var HTML = require(\"fs\").readFileSync(__dirname + \"/test.html\");\r\n    S.ParseWaitTimesHTML(HTML).then((data) => {\r\n        S.Log(JSON.stringify(data, null, 2));\r\n    });\r\n}"]}