{"version":3,"sources":["../../lib/efteling/index.js"],"names":["crypto","require","Moment","Park","GeoLocation","s_apiVersion","Symbol","s_cryptoKey","s_cryptoCipher","s_cryptoIV","s_digestKey","s_searchURL","s_waitTimesURL","Efteling","options","name","timezone","latitude","longitude","api_version","digest_key","crypto_key","crypto_cipher","crypto_iv","Buffer","search_url","wait_times_url","Cache","Wrap","FetchPOIData","bind","MakeRequest","url","data","then","result","hits","hit","Error","poiData","map","fields","category","id","latlon","match","exec","location","GetPOIData","FetchWaitTimesData","waitData","AttractionInfo","item","Type","Id","rideObject","GetRideObject","WaitTime","State","parseInt","WaitingTime","Promise","resolve","decodedBuffer","from","toString","decipher","createDecipheriv","concat","update","final","replace","hmac","createHmac","digest","requestOptions","error","GetDigest","Log","headers","body","returnFullResponse","json","HTTP","response","reject","constructor","JSONResult","JSON","parse","e","decryptedString","DecryptString","endMonth","tz","Timezone","add","ScheduleDays","datePointer","months","format","isSameOrBefore","push","month","year","all","FetchOpeningTimesByMonth","results","hours","times","Schedule","SetDate","date","open","openingTime","closingTime","close","OpeningHours","i","Date","Open","Close","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const crypto = require(\"crypto\");\r\nconst Moment = require(\"moment-timezone\");\r\n\r\nconst Park = require(\"../park\");\r\n\r\nconst GeoLocation = require(\"../geoLocation.js\");\r\n\r\nconst s_apiVersion = Symbol();\r\nconst s_cryptoKey = Symbol();\r\nconst s_cryptoCipher = Symbol();\r\nconst s_cryptoIV = Symbol();\r\nconst s_digestKey = Symbol();\r\nconst s_searchURL = Symbol();\r\nconst s_waitTimesURL = Symbol();\r\n\r\n/**\r\n * Implements the Efteling API framework.\r\n * @class\r\n * @extends Park\r\n */\r\nclass Efteling extends Park {\r\n    /**\r\n     * Create new Efteling Object.\r\n     * @param {Object} [options]\r\n     * @param {String} [options.api_version] Version of the API to reference in request headers\r\n     * @param {String} [options.digest_key] Key used to generate URL header digest\r\n     * @param {String} [options.crypto_key] Key to decrypt wait times\r\n     * @param {String} [options.crypto_cipher] Cipher to decrypt wait times\r\n     * @param {Buffer} [options.crypto_iv] IV to decrypt wait times\r\n     * @param {String} [options.search_url] URL used for fetching POI data\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Efteling\";\r\n\r\n        options.timezone = options.timezone || \"Europe/Amsterdam\";\r\n\r\n        // set park's location as it's entrance\r\n        options.latitude = options.latitude || 51.64990915659694;\r\n        options.longitude = options.longitude || 5.043561458587647;\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // api settings\r\n        this[s_apiVersion] = options.api_version || \"4\";\r\n\r\n        // URL generation settings\r\n        this[s_digestKey] = options.digest_key || \"blblblblbla\";\r\n\r\n        // decryption settings\r\n        this[s_cryptoKey] = options.crypto_key || \"1768257091023496\";\r\n        this[s_cryptoCipher] = options.crypto_cipher || \"aes-128-cbc\";\r\n        this[s_cryptoIV] = options.crypto_iv || new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n\r\n        // URL settings\r\n        this[s_searchURL] = options.search_url || \"http://prd-search-acs.efteling.com/2013-01-01/\";\r\n        this[s_waitTimesURL] = options.wait_times_url || \"https://mobile-services.efteling.com/wis/\";\r\n    }\r\n\r\n    /**\r\n     * Get POI data for this park (from the cache or fetch fresh data if none is cached)\r\n     * @returns {Promise}\r\n     */\r\n    GetPOIData() {\r\n        return this.Cache.Wrap(\"poidata\", this.FetchPOIData.bind(this), 60 * 60 * 24);\r\n    }\r\n\r\n    /**\r\n     * Fetch POI data for the park.\r\n     * Don't call this function directly unless you know what you're doing. Use GetPOIData instead to use cached data when possible.\r\n     * @returns {Promise} Object of Ride IDs => Object containing name and location (GeoLocation object, if location is available for this ride)\r\n     */\r\n    FetchPOIData() {\r\n        return this.MakeRequest({\r\n            url: `${this[s_searchURL]}search`,\r\n            data: {\r\n                \"size\": 1000,\r\n                \"q.parser\": \"structured\",\r\n                \"q\": \"(phrase field=language 'en')\"\r\n            }\r\n        }).then((result) => {\r\n            if (!result || !result.hits || !result.hits.hit) {\r\n                throw new Error(`No results returned for POI data for Efteling Park: ${result}`);\r\n            }\r\n\r\n            var poiData = {};\r\n\r\n            result.hits.hit.map((hit) => {\r\n                if (hit.fields) {\r\n                    // ignore non-attractions\r\n                    if (hit.fields.category == \"attraction\") {\r\n                        poiData[hit.fields.id] = {\r\n                            name: hit.fields.name,\r\n                        };\r\n\r\n                        // try to parse lat/long\r\n                        //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\r\n                        if (hit.fields.latlon && hit.fields.latlon != \"0.0,0.0\") {\r\n                            var match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\r\n                            if (match) {\r\n                                poiData[hit.fields.id].location = new GeoLocation({\r\n                                    latitude: match[1],\r\n                                    longitude: match[2]\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            return poiData;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch park wait times\r\n     * @returns {Promise}\r\n     */\r\n    FetchWaitTimes() {\r\n        // first, get POI data\r\n        return this.GetPOIData().then((poiData) => {\r\n            // then, get latest wait time results\r\n            return this.FetchWaitTimesData().then((waitData) => {\r\n                // parse and inject into park data\r\n                if (!waitData.AttractionInfo) throw new Error(\"No AttractionInfo found for Efteling Park response\");\r\n\r\n                waitData.AttractionInfo.map((item) => {\r\n                    // check we have POI data and item is an attraction\r\n                    if (item.Type == \"Attraction\" && poiData[item.Id]) {\r\n                        var rideObject = this.GetRideObject({\r\n                            id: item.Id,\r\n                            name: poiData[item.Id].name\r\n                        });\r\n\r\n                        if (rideObject) {\r\n                            // update ride with wait time data\r\n                            //  if the State isn't \"open\", assume ride is closed\r\n                            // TODO - learn how Efteling marks rides as under refurb and set = -2\r\n                            rideObject.WaitTime = item.State == \"open\" ? parseInt(item.WaitingTime, 10) : -1;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                return Promise.resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch the raw wait times data for Efteling Park\r\n     */\r\n    FetchWaitTimesData() {\r\n        return this.MakeRequest({\r\n            url: this[s_waitTimesURL]\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Decrypt an encrypted string from the Efteling API\r\n     * @param {String|Buffer} data \r\n     */\r\n    DecryptString(data) {\r\n        // step 1: decode Base64 (make sure it's in ascii format first, since it's a base64 string in text, not actual base64 data)\r\n        const decodedBuffer = Buffer.from(data.toString(\"ascii\"), \"base64\");\r\n        // step 2: setup decryption\r\n        const decipher = crypto.createDecipheriv(this[s_cryptoCipher], this[s_cryptoKey], this[s_cryptoIV]);\r\n        // step 3: decrypt and return as utf8 string\r\n        return Buffer.concat([\r\n            decipher.update(decodedBuffer),\r\n            decipher.final()\r\n        ]).toString(\"utf8\");\r\n    }\r\n\r\n    /**\r\n     * Generate a digest for given URL\r\n     * @param {String} URL\r\n     */\r\n    GetDigest(url) {\r\n        // remove http(s) from string\r\n        url = url.replace(/^https?:\\/\\//, \"\");\r\n        // generate digest\r\n        const hmac = crypto.createHmac(\"sha256\", this[s_digestKey]);\r\n        hmac.update(url);\r\n        return hmac.digest(\"hex\");\r\n    }\r\n\r\n    /**\r\n     * Make an API request against the Efteling API\r\n     * Injects required headers and passes request through to standard HTTP method\r\n     * See HTTP for full documentation on how to use\r\n     * @param {Object} requestOptions \r\n     * @return {Promise}\r\n     */\r\n    MakeRequest(requestOptions) {\r\n        if (!requestOptions.url) {\r\n            return Promise.error(\"No URL supplied\");\r\n        }\r\n\r\n        // generate digest needed to make URL request\r\n        const digest = this.GetDigest(requestOptions.url);\r\n        this.Log(`Generated digest for url \"${requestOptions.url}\": ${digest}`);\r\n\r\n        // add our required headers\r\n        if (!requestOptions.headers) requestOptions.headers = {};\r\n        requestOptions.headers[\"X-Digest\"] = digest;\r\n        requestOptions.headers[\"X-Api-Version\"] = this[s_apiVersion];\r\n\r\n        if (requestOptions.body || requestOptions.data) {\r\n            requestOptions.headers[\"Content-Type\"] = \"application/json\";\r\n        }\r\n\r\n        // return full body (so we don't try to auto-parse JSON data as it's often encrypted)\r\n        requestOptions.returnFullResponse = true;\r\n        // don't auto-JSON request or response\r\n        requestOptions.json = false;\r\n\r\n        return this.HTTP(requestOptions).then((response) => {\r\n            // intercept the HTTP method's response to sort out any encrypted data responses...\r\n\r\n            if (!response.body) return Promise.reject(\"Failed to get network response\");\r\n\r\n            // check if we've already got a valid JSON object as a response\r\n            if (response.body.constructor === {}.constructor || response.body.constructor === [].constructor) {\r\n                return Promise.resolve(response.body);\r\n            }\r\n\r\n            // try to parse result body into JSON first\r\n            var JSONResult;\r\n            try {\r\n                JSONResult = JSON.parse(response.body);\r\n                return Promise.resolve(JSONResult);\r\n            } catch (e) {\r\n                // failed to parse JSON data? assume it's encrypted and decrypt it first\r\n                var decryptedString;\r\n                try {\r\n                    decryptedString = this.DecryptString(response.body);\r\n                } catch (e) {\r\n                    throw new Error(`Failed to decrypt string: ${response.body}`);\r\n                }\r\n\r\n                // got decrypted string, try to parse it\r\n                try {\r\n                    JSONResult = JSON.parse(decryptedString);\r\n                    return Promise.resolve(JSONResult);\r\n                } catch (e) {\r\n                    // also failed to parse decrypted data? reject\r\n                    throw new Error(`Failed to parse decrypted Efteling string: ${decryptedString}`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Request park opening times.\r\n     * @returns {Promise}\r\n     */\r\n    FetchOpeningTimes() {\r\n        // calculate how many (and which) months we want to check\r\n        const endMonth = Moment().tz(this.Timezone).add(this.ScheduleDays, \"days\");\r\n        var datePointer = Moment().tz(this.Timezone);\r\n        const months = [];\r\n\r\n        this.Log(`Fetching opening hours between ${datePointer.format()} and ${endMonth.format()}`);\r\n\r\n        // slide along between start and end until we go past endMonth to get an array of required month/year combos\r\n        while (datePointer.isSameOrBefore(endMonth, \"month\")) {\r\n            months.push({\r\n                month: datePointer.format(\"M\"),\r\n                year: datePointer.format(\"YYYY\")\r\n            });\r\n            datePointer.add(1, \"months\");\r\n        }\r\n\r\n        // loop through each month, calling FetchOpeningTimesByMonth\r\n        return Promise.all(months.map((month) => {\r\n            return this.FetchOpeningTimesByMonth(month.month, month.year);\r\n        })).then((results) => {\r\n            // inject results into calendar\r\n            results.map((hours) => {\r\n                hours.map((times) => {\r\n                    this.Schedule.SetDate({\r\n                        date: times.open,\r\n                        openingTime: times.open,\r\n                        closingTime: times.close\r\n                    });\r\n                });\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch park opening times for a specific month and add to park's opening times\r\n     * @param {String} month\r\n     * @param {String} [year]\r\n     * @returns {Promise} Array of Objects containing \"open\" and \"close\" Moment objects\r\n     */\r\n    FetchOpeningTimesByMonth(month, year) {\r\n        // default to current year if none supplied\r\n        if (!year) {\r\n            year = Moment.tz(this.Timezone).format(\"YYYY\");\r\n        }\r\n\r\n        return this.HTTP({\r\n            url: `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\r\n            headers: {\r\n                \"X-Requested-With\": \"XMLHttpRequest\"\r\n            }\r\n        }).then((data) => {\r\n            if (!data) throw new Error(`Invalid data returned for park opening hours for ${month}/${year}`);\r\n            if (!data.OpeningHours) throw new Error(`No park opening hours data returned for ${month}/${year}`);\r\n\r\n            // build array of Moment objects for each open and close time\r\n            const result = [];\r\n            for (var i = 0, date; date = data.OpeningHours[i++];) {\r\n                const open = Moment.tz(`${date.Date}${date.Open}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\r\n                const close = Moment.tz(`${date.Date}${date.Close}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\r\n                result.push({\r\n                    open,\r\n                    close,\r\n                });\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = Efteling;"]}