"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var crypto = require("crypto");
var Moment = require("moment-timezone");

var Park = require("../park");

var GeoLocation = require("../geoLocation.js");

var s_apiVersion = Symbol();
var s_cryptoKey = Symbol();
var s_cryptoCipher = Symbol();
var s_cryptoIV = Symbol();
var s_digestKey = Symbol();
var s_searchURL = Symbol();
var s_waitTimesURL = Symbol();

/**
 * Implements the Efteling API framework.
 * @class
 * @extends Park
 */

var Efteling = function (_Park) {
    _inherits(Efteling, _Park);

    /**
     * Create new Efteling Object.
     * @param {Object} [options]
     * @param {String} [options.api_version] Version of the API to reference in request headers
     * @param {String} [options.digest_key] Key used to generate URL header digest
     * @param {String} [options.crypto_key] Key to decrypt wait times
     * @param {String} [options.crypto_cipher] Cipher to decrypt wait times
     * @param {Buffer} [options.crypto_iv] IV to decrypt wait times
     * @param {String} [options.search_url] URL used for fetching POI data
     */
    function Efteling() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Efteling);

        options.name = options.name || "Efteling";

        options.timezone = options.timezone || "Europe/Amsterdam";

        // set park's location as it's entrance
        options.latitude = options.latitude || 51.64990915659694;
        options.longitude = options.longitude || 5.043561458587647;

        // inherit from base class

        // api settings
        var _this = _possibleConstructorReturn(this, (Efteling.__proto__ || Object.getPrototypeOf(Efteling)).call(this, options));

        _this[s_apiVersion] = options.api_version || "4";

        // URL generation settings
        _this[s_digestKey] = options.digest_key || "blblblblbla";

        // decryption settings
        _this[s_cryptoKey] = options.crypto_key || "1768257091023496";
        _this[s_cryptoCipher] = options.crypto_cipher || "aes-128-cbc";
        _this[s_cryptoIV] = options.crypto_iv || new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

        // URL settings
        _this[s_searchURL] = options.search_url || "http://prd-search-acs.efteling.com/2013-01-01/";
        _this[s_waitTimesURL] = options.wait_times_url || "https://mobile-services.efteling.com/wis/";
        return _this;
    }

    /**
     * Get POI data for this park (from the cache or fetch fresh data if none is cached)
     * @returns {Promise}
     */


    _createClass(Efteling, [{
        key: "GetPOIData",
        value: function GetPOIData() {
            return this.Cache.Wrap("poidata", this.FetchPOIData.bind(this), 60 * 60 * 24);
        }

        /**
         * Fetch POI data for the park.
         * Don't call this function directly unless you know what you're doing. Use GetPOIData instead to use cached data when possible.
         * @returns {Promise} Object of Ride IDs => Object containing name and location (GeoLocation object, if location is available for this ride)
         */

    }, {
        key: "FetchPOIData",
        value: function FetchPOIData() {
            return this.MakeRequest({
                url: this[s_searchURL] + "search",
                data: {
                    "size": 1000,
                    "q.parser": "structured",
                    "q": "(phrase field=language 'en')"
                }
            }).then(function (result) {
                if (!result || !result.hits || !result.hits.hit) {
                    throw new Error("No results returned for POI data for Efteling Park: " + result);
                }

                var poiData = {};

                result.hits.hit.map(function (hit) {
                    if (hit.fields) {
                        // ignore non-attractions
                        if (hit.fields.category == "attraction") {
                            poiData[hit.fields.id] = {
                                name: hit.fields.name
                            };

                            // try to parse lat/long
                            //  edge-case: some rides have dud "0.0,0.0" location, ignore these
                            if (hit.fields.latlon && hit.fields.latlon != "0.0,0.0") {
                                var match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);
                                if (match) {
                                    poiData[hit.fields.id].location = new GeoLocation({
                                        latitude: match[1],
                                        longitude: match[2]
                                    });
                                }
                            }
                        }
                    }
                });

                return poiData;
            });
        }

        /**
         * Fetch park wait times
         * @returns {Promise}
         */

    }, {
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            var _this2 = this;

            // first, get POI data
            return this.GetPOIData().then(function (poiData) {
                // then, get latest wait time results
                return _this2.FetchWaitTimesData().then(function (waitData) {
                    // parse and inject into park data
                    if (!waitData.AttractionInfo) throw new Error("No AttractionInfo found for Efteling Park response");

                    waitData.AttractionInfo.map(function (item) {
                        // check we have POI data and item is an attraction
                        if (item.Type == "Attraction" && poiData[item.Id]) {
                            var rideObject = _this2.GetRideObject({
                                id: item.Id,
                                name: poiData[item.Id].name
                            });

                            if (rideObject) {
                                // update ride with wait time data
                                //  if the State isn't "open", assume ride is closed
                                // TODO - learn how Efteling marks rides as under refurb and set = -2
                                rideObject.WaitTime = item.State == "open" ? parseInt(item.WaitingTime, 10) : -1;
                            }
                        }
                    });

                    return Promise.resolve();
                });
            });
        }

        /**
         * Fetch the raw wait times data for Efteling Park
         */

    }, {
        key: "FetchWaitTimesData",
        value: function FetchWaitTimesData() {
            return this.MakeRequest({
                url: this[s_waitTimesURL]
            });
        }

        /**
         * Decrypt an encrypted string from the Efteling API
         * @param {String|Buffer} data 
         */

    }, {
        key: "DecryptString",
        value: function DecryptString(data) {
            // step 1: decode Base64 (make sure it's in ascii format first, since it's a base64 string in text, not actual base64 data)
            var decodedBuffer = Buffer.from(data.toString("ascii"), "base64");
            // step 2: setup decryption
            var decipher = crypto.createDecipheriv(this[s_cryptoCipher], this[s_cryptoKey], this[s_cryptoIV]);
            // step 3: decrypt and return as utf8 string
            return Buffer.concat([decipher.update(decodedBuffer), decipher.final()]).toString("utf8");
        }

        /**
         * Generate a digest for given URL
         * @param {String} URL
         */

    }, {
        key: "GetDigest",
        value: function GetDigest(url) {
            // remove http(s) from string
            url = url.replace(/^https?:\/\//, "");
            // generate digest
            var hmac = crypto.createHmac("sha256", this[s_digestKey]);
            hmac.update(url);
            return hmac.digest("hex");
        }

        /**
         * Make an API request against the Efteling API
         * Injects required headers and passes request through to standard HTTP method
         * See HTTP for full documentation on how to use
         * @param {Object} requestOptions 
         * @return {Promise}
         */

    }, {
        key: "MakeRequest",
        value: function MakeRequest(requestOptions) {
            var _this3 = this;

            if (!requestOptions.url) {
                return Promise.error("No URL supplied");
            }

            // generate digest needed to make URL request
            var digest = this.GetDigest(requestOptions.url);
            this.Log("Generated digest for url \"" + requestOptions.url + "\": " + digest);

            // add our required headers
            if (!requestOptions.headers) requestOptions.headers = {};
            requestOptions.headers["X-Digest"] = digest;
            requestOptions.headers["X-Api-Version"] = this[s_apiVersion];

            if (requestOptions.body || requestOptions.data) {
                requestOptions.headers["Content-Type"] = "application/json";
            }

            // return full body (so we don't try to auto-parse JSON data as it's often encrypted)
            requestOptions.returnFullResponse = true;
            // don't auto-JSON request or response
            requestOptions.json = false;

            return this.HTTP(requestOptions).then(function (response) {
                // intercept the HTTP method's response to sort out any encrypted data responses...

                if (!response.body) return Promise.reject("Failed to get network response");

                // check if we've already got a valid JSON object as a response
                if (response.body.constructor === {}.constructor || response.body.constructor === [].constructor) {
                    return Promise.resolve(response.body);
                }

                // try to parse result body into JSON first
                var JSONResult;
                try {
                    JSONResult = JSON.parse(response.body);
                    return Promise.resolve(JSONResult);
                } catch (e) {
                    // failed to parse JSON data? assume it's encrypted and decrypt it first
                    var decryptedString;
                    try {
                        decryptedString = _this3.DecryptString(response.body);
                    } catch (e) {
                        throw new Error("Failed to decrypt string: " + response.body);
                    }

                    // got decrypted string, try to parse it
                    try {
                        JSONResult = JSON.parse(decryptedString);
                        return Promise.resolve(JSONResult);
                    } catch (e) {
                        // also failed to parse decrypted data? reject
                        throw new Error("Failed to parse decrypted Efteling string: " + decryptedString);
                    }
                }
            });
        }

        /**
         * Request park opening times.
         * @returns {Promise}
         */

    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            var _this4 = this;

            // calculate how many (and which) months we want to check
            var endMonth = Moment().tz(this.Timezone).add(this.ScheduleDays, "days");
            var datePointer = Moment().tz(this.Timezone);
            var months = [];

            this.Log("Fetching opening hours between " + datePointer.format() + " and " + endMonth.format());

            // slide along between start and end until we go past endMonth to get an array of required month/year combos
            while (datePointer.isSameOrBefore(endMonth, "month")) {
                months.push({
                    month: datePointer.format("M"),
                    year: datePointer.format("YYYY")
                });
                datePointer.add(1, "months");
            }

            // loop through each month, calling FetchOpeningTimesByMonth
            return Promise.all(months.map(function (month) {
                return _this4.FetchOpeningTimesByMonth(month.month, month.year);
            })).then(function (results) {
                // inject results into calendar
                results.map(function (hours) {
                    hours.map(function (times) {
                        _this4.Schedule.SetDate({
                            date: times.open,
                            openingTime: times.open,
                            closingTime: times.close
                        });
                    });
                });
                return results;
            });
        }

        /**
         * Fetch park opening times for a specific month and add to park's opening times
         * @param {String} month
         * @param {String} [year]
         * @returns {Promise} Array of Objects containing "open" and "close" Moment objects
         */

    }, {
        key: "FetchOpeningTimesByMonth",
        value: function FetchOpeningTimesByMonth(month, year) {
            var _this5 = this;

            // default to current year if none supplied
            if (!year) {
                year = Moment.tz(this.Timezone).format("YYYY");
            }

            return this.HTTP({
                url: "https://www.efteling.com/service/cached/getpoiinfo/en/" + year + "/" + month,
                headers: {
                    "X-Requested-With": "XMLHttpRequest"
                }
            }).then(function (data) {
                if (!data) throw new Error("Invalid data returned for park opening hours for " + month + "/" + year);
                if (!data.OpeningHours) throw new Error("No park opening hours data returned for " + month + "/" + year);

                // build array of Moment objects for each open and close time
                var result = [];
                for (var i = 0, date; date = data.OpeningHours[i++];) {
                    var open = Moment.tz("" + date.Date + date.Open, "YYYY-MM-DDHH:mm", _this5.Timezone);
                    var close = Moment.tz("" + date.Date + date.Close, "YYYY-MM-DDHH:mm", _this5.Timezone);
                    result.push({
                        open: open,
                        close: close
                    });
                }
                return result;
            });
        }
    }]);

    return Efteling;
}(Park);

module.exports = Efteling;
//# sourceMappingURL=index.js.map